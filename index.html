<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>派手なシューティングゲーム</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
html, body {
background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
font-family: 'Arial', sans-serif;
overflow: hidden;
color: white;
user-select: none;
height: 100%;
width: 100%;
position: relative;
}
#gameCanvas {
display: block;
margin: 10px auto 0;
border: 3px solid #ff6b6b;
border-radius: 10px;
box-shadow: 0 0 30px rgba(255, 107, 107, 0.5);
background: linear-gradient(180deg, #000011, #001122);
max-width: 95vw;
max-height: 85vh;
}
#ui {
position: fixed;
top: 30px;
left: 30px;
z-index: 1000;
font-size: 24px;
font-weight: bold;
text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
pointer-events: none;
}
#gameOver {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
padding: 30px;
border-radius: 20px;
text-align: center;
display: none;
z-index: 2000;
box-shadow: 0 0 50px rgba(255, 107, 107, 0.8);
animation: pulse 1s infinite;
}
@keyframes pulse {
0%, 100% { transform: translate(-50%, -50%) scale(1); }
50% { transform: translate(-50%, -50%) scale(1.05); }
}
#startScreen {
position: fixed;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
background: linear-gradient(45deg, #667eea, #764ba2);
padding: 40px;
border-radius: 20px;
text-align: center;
z-index: 2000;
box-shadow: 0 0 50px rgba(102, 126, 234, 0.8);
}
button {
background: linear-gradient(45deg, #ff6b6b, #feca57);
border: none;
padding: 15px 30px;
font-size: 20px;
color: white;
border-radius: 25px;
cursor: pointer;
margin: 10px;
transition: all 0.3s;
font-weight: bold;
text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
}
button:hover {
transform: scale(1.1);
box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
}
#instructions {
font-size: 16px;
margin: 20px 0;
line-height: 1.5;
}
</style>
</head>
<body>
<div id="startScreen">
<h1 style="margin-bottom: 20px; font-size: 28px; color: #fff;">🚀 スペースシューター 🚀</h1>
<div id="instructions">
<p>🎯 1ぷんかんでどれだけてんすうをかせげるかな？</p>
<p>⬅️➡️ やじるしキーでいどう（ブラウザのやじるしボタンもOK）</p>
<p>だんは じどうで うちつづけます！</p>
<p>⭐ ボーナスアイテムをゲット！</p>
<p>⚡ パワーアイテムでだんがパワーアップ！</p>
</div>
<button onclick="startGame()">ゲームスタート！</button>
</div>
<div id="ui">
<div>スコア: <span id="score">0</span></div>
<div>じかん: <span id="timer">60</span>びょう</div>
<div>ライフ: <span id="lives">❤️❤️❤️</span></div>
<div>パワー: <span id="power">Lv.0</span></div>
</div>
<div id="gameOver">
<h2>ゲームしゅうりょう！</h2>
<p>さいしゅうスコア: <span id="finalScore">0</span></p>
<button onclick="restartGame()">もう一度プレイ</button>
</div>
<canvas id="gameCanvas" width="1200" height="800"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let gameState = {
running: false,
score: 0,
lives: 3,
timer: 60,
powerLevel: 0,
player: { x: 600, y: 700, width: 40, height: 40, speed: 8 },
bullets: [],
enemies: [],
particles: [],
powerups: [],
keys: {},
lastEnemySpawn: 0,
lastPowerupSpawn: 0,
lastShot: 0,
timerInterval: null,
uiInterval: null
};

// 背景初期化関数
function initializeBackground() {
ctx.fillStyle = 'rgba(0, 0, 17, 1)';
ctx.fillRect(0, 0, canvas.width, canvas.height);
}

// キー入力処理
document.addEventListener('keydown', (e) => {
gameState.keys[e.code] = true;
if (['ArrowLeft', 'ArrowRight', 'Space', 'Enter'].includes(e.code)) {
e.preventDefault();
}
});
document.addEventListener('keyup', (e) => {
gameState.keys[e.code] = false;
if (['ArrowLeft', 'ArrowRight', 'Space', 'Enter'].includes(e.code)) {
e.preventDefault();
}
});

// パーティクル効果
function createParticles(x, y, color, count = 10) {
for (let i = 0; i < count; i++) {
gameState.particles.push({
x: x,
y: y,
vx: (Math.random() - 0.5) * 10,
vy: (Math.random() - 0.5) * 10,
life: 1,
decay: 0.02,
size: Math.random() * 5 + 2,
color: color
});
}
}

// 敵の生成
function spawnEnemy() {
const types = [
{ color: '#ff1744', speed: 2, points: 10, size: 35 },
{ color: '#d50000', speed: 3, points: 20, size: 30 },
{ color: '#aa0000', speed: 4, points: 30, size: 25 }
];
const type = types[Math.floor(Math.random() * types.length)];
gameState.enemies.push({
x: Math.random() * (canvas.width - type.size),
y: -type.size,
width: type.size,
height: type.size,
speed: type.speed,
color: type.color,
points: type.points,
hp: Math.floor(type.points / 10)
});
}

// パワーアップアイテムの生成
function spawnPowerup() {
const types = [
{ type: 'star', color: '#ffeb3b', points: 100, effect: 'score' },
{ type: 'heart', color: '#e91e63', points: 0, effect: 'life' },
{ type: 'diamond', color: '#00bcd4', points: 200, effect: 'score' },
{ type: 'power', color: '#9c27b0', points: 50, effect: 'power' }
];
const type = types[Math.floor(Math.random() * types.length)];
gameState.powerups.push({
x: Math.random() * (canvas.width - 25),
y: -25,
width: 25,
height: 25,
speed: 2,
...type,
rotation: 0
});
}

// 弾の発射
function shoot() {
const baseX = gameState.player.x + gameState.player.width / 2;
const baseY = gameState.player.y - 15;
if (gameState.powerLevel === 0) {
gameState.bullets.push({
x: baseX - 5,
y: baseY,
width: 10,
height: 25,
vx: 0,
vy: -12,
color: '#00ff88'
});
} else if (gameState.powerLevel === 1) {
gameState.bullets.push({
x: baseX - 5, y: baseY, width: 10, height: 25,
vx: 0, vy: -12, color: '#00ff88'
});
gameState.bullets.push({
x: baseX - 15, y: baseY, width: 8, height: 20,
vx: -3, vy: -10, color: '#00ccff'
});
gameState.bullets.push({
x: baseX + 5, y: baseY, width: 8, height: 20,
vx: 3, vy: -10, color: '#00ccff'
});
} else if (gameState.powerLevel === 2) {
const angles = [-0.6, -0.3, 0, 0.3, 0.6];
angles.forEach((angle, i) => {
gameState.bullets.push({
x: baseX - 5 + (i-2) * 8,
y: baseY,
width: 8,
height: 20,
vx: Math.sin(angle) * 12,
vy: -Math.cos(angle) * 12,
color: i === 2 ? '#00ff88' : '#00ccff'
});
});
} else {
const angles = [-0.8, -0.5, -0.25, 0, 0.25, 0.5, 0.8];
angles.forEach((angle, i) => {
gameState.bullets.push({
x: baseX - 5 + (i-3) * 6,
y: baseY,
width: 8,
height: 18,
vx: Math.sin(angle) * 12,
vy: -Math.cos(angle) * 12,
color: i === 3 ? '#00ff88' : '#ffaa00'
});
});
}
}

// 衝突判定
function checkCollision(a, b) {
return a.x < b.x + b.width &&
a.x + a.width > b.x &&
a.y < b.y + b.height &&
a.y + a.height > b.y;
}

// プレイヤーの描画
function drawPlayer() {
const p = gameState.player;
ctx.save();
ctx.translate(p.x + p.width/2, p.y + p.height/2);
const gradient = ctx.createLinearGradient(-20, -20, 20, 20);
gradient.addColorStop(0, '#00bfff');
gradient.addColorStop(0.5, '#1e90ff');
gradient.addColorStop(1, '#0066cc');
ctx.fillStyle = gradient;
ctx.beginPath();
ctx.moveTo(0, -18);
ctx.lineTo(12, -8);
ctx.lineTo(12, 8);
ctx.lineTo(0, 18);
ctx.lineTo(-12, 8);
ctx.lineTo(-12, -8);
ctx.closePath();
ctx.fill();
ctx.fillStyle = '#4169e1';
ctx.fillRect(-20, -5, 8, 10);
ctx.fillRect(12, -5, 8, 10);
ctx.fillStyle = '#ff4500';
ctx.fillRect(-6, 18, 3, 12);
ctx.fillRect(-1, 18, 3, 12);
ctx.fillRect(4, 18, 3, 12);
ctx.fillStyle = '#ffff00';
ctx.fillRect(-5, 18, 2, 8);
ctx.fillRect(0, 18, 2, 8);
ctx.fillRect(5, 18, 2, 8);
ctx.fillStyle = '#00ffff';
ctx.shadowColor = '#00ffff';
ctx.shadowBlur = 15;
ctx.beginPath();
ctx.arc(0, -5, 5, 0, Math.PI * 2);
ctx.fill();
ctx.shadowBlur = 0;
ctx.fillStyle = '#ffffff';
ctx.fillRect(-2, -20, 4, 8);
ctx.restore();
}

// エフェクト描画
function drawEffects() {
gameState.particles.forEach((p, index) => {
ctx.save();
ctx.globalAlpha = p.life;
ctx.fillStyle = p.color;
ctx.beginPath();
ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
ctx.fill();
ctx.restore();
p.x += p.vx;
p.y += p.vy;
p.life -= p.decay;
if (p.life <= 0) {
gameState.particles.splice(index, 1);
}
});
}

// ゲーム更新
function update() {
if (!gameState.running) return;
if ((gameState.keys['ArrowLeft'] || gameState.keys['BrowserBack']) && gameState.player.x > 0) {
gameState.player.x -= gameState.player.speed;
}
if ((gameState.keys['ArrowRight'] || gameState.keys['BrowserForward']) && gameState.player.x < canvas.width - gameState.player.width) {
gameState.player.x += gameState.player.speed;
}
if (Date.now() - gameState.lastShot > 200) {
shoot();
gameState.lastShot = Date.now();
}
gameState.bullets.forEach((bullet, index) => {
bullet.x += bullet.vx;
bullet.y += bullet.vy;
if (bullet.y < -50 || bullet.x < -50 || bullet.x > canvas.width + 50) {
gameState.bullets.splice(index, 1);
}
});
gameState.enemies.forEach((enemy, index) => {
enemy.y += enemy.speed;
if (enemy.y > canvas.height) {
gameState.enemies.splice(index, 1);
}
});
gameState.powerups.forEach((powerup, index) => {
powerup.y += powerup.speed;
powerup.rotation += 0.1;
if (powerup.y > canvas.height) {
gameState.powerups.splice(index, 1);
}
});
gameState.bullets.forEach((bullet, bulletIndex) => {
gameState.enemies.forEach((enemy, enemyIndex) => {
if (checkCollision(bullet, enemy)) {
enemy.hp--;
gameState.bullets.splice(bulletIndex, 1);
if (enemy.hp <= 0) {
gameState.score += enemy.points;
createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, enemy.color, 15);
gameState.enemies.splice(enemyIndex, 1);
}
}
});
});
gameState.enemies.forEach((enemy, index) => {
if (checkCollision(gameState.player, enemy)) {
gameState.lives--;
createParticles(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff6b6b', 20);
gameState.enemies.splice(index, 1);
if (gameState.lives <= 0) {
endGame();
}
}
});
gameState.powerups.forEach((powerup, index) => {
if (checkCollision(gameState.player, powerup)) {
if (powerup.effect === 'life' && gameState.lives < 3) {
gameState.lives++;
} else if (powerup.effect === 'power') {
gameState.powerLevel = Math.min(gameState.powerLevel + 1, 5);
gameState.score += powerup.points;
} else {
gameState.score += powerup.points;
}
createParticles(powerup.x + powerup.width/2, powerup.y + powerup.height/2, powerup.color, 12);
gameState.powerups.splice(index, 1);
}
});
if (Date.now() - gameState.lastEnemySpawn > 1000) {
spawnEnemy();
gameState.lastEnemySpawn = Date.now();
}
if (Date.now() - gameState.lastPowerupSpawn > 5000) {
spawnPowerup();
gameState.lastPowerupSpawn = Date.now();
}
}

// 描画
function draw() {
ctx.fillStyle = 'rgba(0, 0, 17, 0.1)';
ctx.fillRect(0, 0, canvas.width, canvas.height);
for (let i = 0; i < 50; i++) {
ctx.fillStyle = `rgba(255, 255, 255, ${Math.random()})`;
ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, 1, 1);
}
drawPlayer();
gameState.bullets.forEach(bullet => {
ctx.save();
ctx.fillStyle = bullet.color;
ctx.shadowColor = bullet.color;
ctx.shadowBlur = 15;
ctx.beginPath();
ctx.ellipse(bullet.x + bullet.width/2, bullet.y + bullet.height/2,
bullet.width/2, bullet.height/2, 0, 0, Math.PI * 2);
ctx.fill();
ctx.restore();
});
gameState.enemies.forEach(enemy => {
ctx.save();
ctx.fillStyle = enemy.color;
ctx.shadowColor = enemy.color;
ctx.shadowBlur = 20;
ctx.beginPath();
ctx.moveTo(enemy.x + enemy.width/2, enemy.y);
ctx.lineTo(enemy.x, enemy.y + enemy.height);
ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height);
ctx.closePath();
ctx.fill();
ctx.restore();
});
gameState.powerups.forEach(powerup => {
ctx.save();
ctx.translate(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
ctx.rotate(powerup.rotation);
ctx.fillStyle = powerup.color;
ctx.shadowColor = powerup.color;
ctx.shadowBlur = 25;
if (powerup.type === 'star') {
ctx.beginPath();
for (let i = 0; i < 5; i++) {
const angle = (i * 4 * Math.PI) / 5;
const x = Math.cos(angle) * 12;
const y = Math.sin(angle) * 12;
if (i === 0) ctx.moveTo(x, y);
else ctx.lineTo(x, y);
}
ctx.closePath();
ctx.fill();
} else if (powerup.type === 'heart') {
ctx.fillStyle = powerup.color;
ctx.beginPath();
ctx.arc(-6, -3, 6, 0, Math.PI * 2);
ctx.arc(6, -3, 6, 0, Math.PI * 2);
ctx.fill();
ctx.beginPath();
ctx.moveTo(0, 8);
ctx.lineTo(-10, -2);
ctx.lineTo(10, -2);
ctx.closePath();
ctx.fill();
} else if (powerup.type === 'power') {
ctx.beginPath();
ctx.moveTo(0, -12);
ctx.lineTo(-4, -4);
ctx.lineTo(2, -4);
ctx.lineTo(-2, 4);
ctx.lineTo(4, 4);
ctx.lineTo(0, 12);
ctx.lineTo(0, 4);
ctx.lineTo(-4, 4);
ctx.lineTo(0, -4);
ctx.closePath();
ctx.fill();
} else {
ctx.beginPath();
ctx.moveTo(0, -12);
ctx.lineTo(-8, 0);
ctx.lineTo(0, 12);
ctx.lineTo(8, 0);
ctx.closePath();
ctx.fill();
}
ctx.restore();
});
drawEffects();
}

function gameLoop() {
update();
draw();
requestAnimationFrame(gameLoop);
}

function updateTimer() {
if (gameState.running && gameState.timer > 0) {
gameState.timer--;
document.getElementById('timer').textContent = gameState.timer;
if (gameState.timer <= 0) {
endGame();
}
}
}

function updateUI() {
document.getElementById('score').textContent = gameState.score;
const hearts = '❤️'.repeat(gameState.lives);
document.getElementById('lives').textContent = hearts;
document.getElementById('power').textContent = `Lv.${gameState.powerLevel}`;
}

function resetGameState() {
gameState.running = false;
gameState.score = 0;
gameState.lives = 3;
gameState.timer = 60;
gameState.powerLevel = 0;
gameState.player.x = 600;
gameState.player.y = 700;
gameState.bullets = [];
gameState.enemies = [];
gameState.particles = [];
gameState.powerups = [];
gameState.lastShot = 0;
gameState.lastEnemySpawn = 0;
gameState.lastPowerupSpawn = 0;
if (gameState.timerInterval) {
clearInterval(gameState.timerInterval);
gameState.timerInterval = null;
}
if (gameState.uiInterval) {
clearInterval(gameState.uiInterval);
gameState.uiInterval = null;
}
}

function startGame() {
document.getElementById('startScreen').style.display = 'none';
resetGameState();
// 背景初期化
initializeBackground();
gameState.running = true;
gameState.lastShot = Date.now();
gameState.lastEnemySpawn = Date.now();
gameState.lastPowerupSpawn = Date.now();
gameState.timerInterval = setInterval(updateTimer, 1000);
gameState.uiInterval = setInterval(updateUI, 100);
}

function endGame() {
gameState.running = false;
// インターバルをクリア
if (gameState.timerInterval) {
clearInterval(gameState.timerInterval);
gameState.timerInterval = null;
}
if (gameState.uiInterval) {
clearInterval(gameState.uiInterval);
gameState.uiInterval = null;
}
// 背景初期化
initializeBackground();
document.getElementById('finalScore').textContent = gameState.score;
document.getElementById('gameOver').style.display = 'block';
}

function restartGame() {
document.getElementById('gameOver').style.display = 'none';
startGame();
}

// 初期背景描画
initializeBackground();
gameLoop();
</script>
</body>
</html>
